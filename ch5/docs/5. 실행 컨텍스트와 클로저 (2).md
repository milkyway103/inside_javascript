# 5. 실행 컨텍스트와 클로저 (2)
# 5.3 스코프 체인
스코프 체인은 어떻게 만들어질까?
스코프 체인을 알아야 변수에 대한 인식(Identifier Resolution) 매커니즘을 알 수 있고, 현재 사용되는 변수가 어디에서 선언된 변수인지 정확히 알 수 있다.

자바스크립트도 다른 언어와 마찬가지로 스코프, 즉 유효 범위가 있다. 이 유효 범위 안에서 변수와 함수가 존재한다.
다음은 C언어의 유효 범위를 확인할 수 있는 코드이다.

```c
void example_scope()
{
	int i = 0;
	int value = 1;
	for (i = 0; i < 10; i++) {
		int a = 10;
	}
	printf("a : %d", a); // 컴파일 에러

	if (i == 10) {
		int b = 20;
	}
	printf("b : %d", b); // 컴파일 에러
	printf("value : %d", value); // 1
}
```

C 코드를 예로 들면, `{`, `}`로 묶여 있는 범위 안에서 선언된 변수는 블록이 끝나는 순간 사라지므로, 밖에서는 접근할 수 없다. 특히, 함수의 `{`, `}`뿐만 아니라 `if`, `for`문의 `{`, `}`로 한 블록으로 묶여, 그 안에서 선언된 변수는 밖에서는 접근이 불가능하다. 하지만 자바스크립트에서는 함수 내의 `{`, `}`블록은, 이를 테면 `for() {}`, `if {}`와 같은 구문은 유효 범위가 없다. **오직 함수만이 유효 범위의 한 단위**가 된다. 이 유효 범위를 나타내는 스코프가 `scope` 프로퍼티로 각 함수 객체 내에서 연결 리스트 형식으로 관리되는데, 이를 ::스코프 체인::이라고 한다. 이러한 스코프 체인은 각 실행 컨텍스트의 변수 객체가 구성 요소인 리스트와 같다.


**각각의 함수는 scope 프로퍼티로 자신이 생성된 실행 컨텍스트의 스코프 체인을 참조**한다. 함수가 실행되는 순간 실행 컨텍스트가 만들어지고, **이 실행 컨텍스트는 실행된 함수의 scope 프로퍼티를 기반으로 새로운 스코프 체인을 만든다.**

## 5.3.1 전역 실행 컨텍스트의 스코프 체인
예제 5-3
```javascript
var var1 = 1;
var var2 = 2;
console.log(var1);  // (출력값) 1
console.log(var2);  // (출력값) 2
``` 

예제 5-3은 전역 코드이다. 함수가 선언되지 않아 함수 호출이 없고, 실행 가능한 코드들만 나열되어 있다.
이 자바스크립트 코드를 실행하면,
1. 먼저 전역 실행 컨텍스트가 생성되고
2. 변수 객체가 만들어진다.

현재 전역 실행 컨텍스트 단 하나만 실행되고 있기 때문에 이 변수 객체에게는 참조할 상위 컨텍스트가 없다. 자신이 최상위에 위치하는 변수 객체인 것이다.
따라서, 이 변수 객체의 스코프 체인은 자기 자신만을 가진다.
다시 말해서, 변수 객체의 `scope`는 변수 객체 자신을 가리킨다.
그 후, `var1`, `var2` 변수들이 생성되고 변수 객체에 의해 참조된다.
그리고 이 변수 객체가 곧 전역 객체가 된다.

## 5.3.2 함수를 호출한 경우 생성되는 실행 컨텍스트의 스코프 체인

예제 5-4
```javascript
var var1 = 1;
var var2 = 2;
function func() {
    var var1 = 10;
    var var2 = 20;
    console.log(var1);  // (출력값) 10
    console.log(var2);  // (출력값) 20
}
func();
console.log(var1);  // (출력값) 1
console.log(var2);  // (출력값) 2
```

이 예제를 실행하면 전역 실행 컨텍스트가 생성되고, `func()` 함수 객체가 만들어진다.
함수 객체가 생성될 때, 그 함수 객체의 `scope`는 현재 실행되는 컨텍스트의 변수 객체에 있는 `scope`를 그대로 가진다. 따라서, `func` 함수 객체의 `scope`는 전역 변수 객체가 된다.

`func` 컨텍스트의 스코프 체인은 실행된 함수의 `scope` 프로퍼티를 그대로 복사한 후, 현재 생성된 변수 객체를 복사한 스코프 체인의 맨 앞에 추가한다. `func()` 함수 객체의 `scope` 프로퍼티가 전역 객체 하나만을 가지고 있었으므로, `func` 실행 컨텍스트의 스코프 체인은 `func 변수 객체 - 전역 객체`가 된다.

**스코프 체인 정리**
- 각 함수 객체는 `scope` 프로퍼티로 현재 컨텍스트의 스코프 체인을 참조한다.
- 한 함수가 실행되면 새로운 실행 컨텍스트가 만들어지는데, 이 새로운 실행 컨텍스트는 자신이 사용할 스코프 체인을 다음과 같은 방법으로 만든다 : 현재 실행되는 함수 객체의 `scope` 프로퍼티를 복사하고, 새롭게 생성된 변수 객체를 해당 체인의 제일 앞에 추가한다.
- 요약하면 스코프 체인은 다음과 같이 표현할 수 있다.
::스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인::

예제 5-5
```javascript
var value = "value1";

function printFunc() {
    var value = "value2";

    function printValue() {
        return value;
    }

    console.log(printValue());

}

printFunc();
```

예제 5-6
```javascript
var value = "value1";

function printValue() {
    return value;
}
function printFunc(func) {
    var value = "value2";
    console.log(func());
}
printFunc(printValue);
```

예제 5-6의 경우에는 각 함수 객체가 **처음 생성될 당시** 실행 컨텍스트가 무엇인지를 생각해야 한다. 각 함수 객체가 처음 생성될 때 `scope`는 전역 객체의 `scope`를 참조한다. 따라서 각 함수가 실행될 때 생성되는 실행 컨텍스트의 스코프 체인은 전역 객체와 그 앞에 새롭게 만들어진 변수 객체가 추가된다!

**이렇게 만들어진 스코프 체인으로 식별자 인식(Identifier resolution)이 이루어진다.** 식별자 인식은 스코프 체인의 첫 번째 변수 객체부터 시작한다. 식별자와 대응되는 이름을 가진 프로퍼티가 있는지 확인한다. 함수를 호출할 때 스코프 체인의 가장 앞에 있는 객체가 변수 객체이므로, 이 객체에 있는 공식 인자, 내부 함수, 재역 변수에 대응되는지 먼저 확인한다. 첫 번째 객체에 대응되는 프로퍼티를 발견하지 못하면, 다음 객체로 이동하여 찾는다. 이런 식으로 대응되는 이름의 프로퍼티를 찾을 때까지 계속된다. 여기서 `this`는 식별자가 아닌 키워드로 분류되므로, 스코프 체인의 참조 없이 접근할 수 있다.

cf) 자바스크립트에서는 스코프 체인을 사용자가 임의로 수정할 수 있다 : `with`
`with`은 `eval`과 함께 성능을 높이고자 하는 자바스크립트 프로그래머에게는 사용하지 말아야 할 키워드이다.
`with` 구문은 표현식을 실행하는데, 표현식이 객체이면 객체는 현재 실행 컨텍스트의 스코프 체인에 추가된다 (활성화 객체의 바로 앞에) `with` 구문은 다른 구문(블록 구문일 수도 있음)을 실행하고 실행 컨텍스트의 스코프 체인을 전에 있던 곳에 저장한다.
함수 선언은 `with` 구문의 영향을 받지 않고 함수 객체가 생성되지만, 함수 표현식은 안에서 `with` 구문과 함께 실행될 수 있다.

```javascript
var y = { x:5 };

function withExamFunc() {
	var x = 10;
	var z;

	with(y) {
		z = function() {
			console.log(x);	// (출력값) 5. y 객체의 x가 출력된다.
		}
	}
	z();
}
withExamFunc();
```

`withExamFunc()` 함수가 호출되면 실행 컨텍스트는 전역 변수 객체와 현재 실행 컨텍스트의 변수 객체를 포함하는 스코프 체인이 있다. 여기에, `with` 구문의 실행으로 전역 변수 `y`에 의해 참조되는 객체를 함수 표현식이 실행되는 동안 스코프 체인의 맨 앞에 추가한다.

**호이스팅**
```javascript
foo();
bar();

var foo = funcion() {
	console.log("foo and x = " + x);
};

function bar() {
	console.log("bar and x = +" x);
};

var x = 1;
```

이 예제는 다음과 같다.
```javascript
var foo;

function bar() {
	console.log("bar and x = " + x);
}

var x;

foo(); // TypeError
bar();

foo = function() {
	console.log("foo and x = " + x);
};

x = 1;
```

1. 함수 생성 과정에서 변수 `foo`, 함수 객체 `bar`, 변수 `x`를 차례로 생성한다.
2. `foo`와 `x`에는 `undefined`가 할당된다.
3. 실행이 시작되면 `foo()`, `bar()`를 연속해서 호출하고 `foo`에 함수 객체의 참조가 할당되며, 변수 `x`에 1이 할당된다.
4. 결국, `foo()`에서 “TypeError” 에러가 발생한다.
: `foo`가 선언되어 있기는 하지만 함수가 아니기 때문이다. `foo()`를 커멘트 처리한 후 실행하면 `bar()`에서는 “bar and x=undefined”가 출력된다. `x`에 1이 할당되기 전에 실행했기 때문이다.


#책/인사이드자바스크립트